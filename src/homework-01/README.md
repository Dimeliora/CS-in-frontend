# Домашнее задание #1 - Фундаментальные структуры данных

### 1. Реализация двусвязного двустороннего списка

Список реализуется классом DoublyLinkedListImpl, который предоставляет следующие методы для работы со списком:

- clean - Удаление всех элементов списка
- push - Добавление элемента в конец списка
- pop - Удаление элемента из конца списка
- unshift - Добавление элемента в начало списка
- shift- Удаление элемента из начала списка
- insertBefore - Добавление элемента перед указанным элементом
- insertAfter - Добавление элемента после указанного элемента
- find - Поиск указанного элемента в списке
- remove - Удаление указанного элемента в списке
- reverse - Разворот списка
- values - Получение значение элементов списка (возвращает объект генератора)
- reversedValues - Получение значение элементов списка в обратном порядке (возвращает объект генератора)

Кроме этого у экземпляра списка доступны свойства-аксессоры (геттеры):

- head - Ссылка на первый элемент списка
- tail - Ссылка на последний элемент списка
- isEmpty - Признак наличия элементов в списке

Список реализует интерфейс Iterable (может быть перебран в цикле for...of, развернут оператором spread и т.д.).
Экземпляр списка может быть создан из любого перебираемого объекта (реализующего метод Symbol.iterator), переданного в конструктор класса.

```js
const list = new DoublyLinkedListImpl([1, 2, 3]);

list.push(4);
list.unshift(5);
list.insertAfter(3, 10);
list.find(42);

for (const value of list) {
  console.log(value);
}
```

### 2. Реализация очереди на базе двустороннего двусвязного списка

Очередь реализуется классом QueueImpl. Реализация подразумевает использование класса DoublyLinkedListImpl.
Класс QueueImpl предоставляет следующие методы для работы с очередью:

- enqueue - Добавление элемента в очередь
- dequeue - Изъятие элемента из очереди (в случае пустой очереди выбрасывает исключение)
- peek - Получение первого элемента очереди (без изъятия)

Кроме этого у экземпляра очереди доступно свойства-аксессор (геттер) isEmpty.

```js
const queue = new QueueImpl();

queue.enqueue(1);
queue.enqueue(2);
queue.dequeue();
queue.peek();
```

### 3. Реализация двусторонней очереди на базе двустороннего двусвязного списка

Двусторонняя очередь реализуется классом DequeImpl. Реализация подразумевает использование класса DoublyLinkedListImpl.
Класс DequeImpl предоставляет следующие методы для работы с очередью:

- insertLeft - Добавление элемента в очередь слева
- removeLeft - Удаление элемента из очереди слева
- insertRight - Добавление элемента в очередь справа
- removeRight - Удаление элемента из очереди справа
- peekLeft - Получение первого элемента очереди слева (без изъятия)
- peekRight - Получение первого элемента очереди справа (без изъятия)

Кроме этого у экземпляра очереди доступно свойства-аксессор (геттер) isEmpty.

```js
const deque = new DequeImpl();

deque.insertLeft(1);
deque.insertRight(2);
deque.removeRight();
deque.peekLeft();
```

### 4. Реализация стека на базе массива

Стек реализуется классом StackImpl на базе встроенного класса Array. При создании экземпляра класса необходимо передать в конструктор максимальную длину стека (положительное целое число).
Класс StackImpl предоставляет следующие методы для работы со стеком:

- push - Добавление элемента в стек (выбрасывает исключение, если стек уже полон)
- pop - Снятие элемента со стека (выбрасывает исключение, если стек пуст)
- peek - Просмотр верхнего элемента (без снятия)

Кроме этого у экземпляра списка доступны свойства-аксессоры (геттеры):

- isEmpty - Признак отсутствия элементов в стеке
- isFull - Признак заполненности стека

```js
const stack = new StackImpl();

stack.push(1);
stack.push(2);
stack.pop();
stack.peek();
```

### 5. Реализация структуры на базе массива

Данный тип реализуется классом StructureImpl и является условной реализацией структуры (struct), использует для хранения данных массив заранее определенной длины.

При создании экземпляра класса необходимо передать конструктору массив ключей будущей структуры. В дальнейшем доступ к данным осуществляется по данным ключам посредством методов:

- set - Установка значения по ключу
- get - Чтение значения по ключу

При обращении к несуществующему ключу выбрасывается исключение.

Размер массива для хранения значений определяется на этапе создания экземпляра класса по числу переданных аргументов. Отображение ключей на индексы массива осуществляется создаваемой при инстанцировании функцией (кодогенерация посредством конструктора Function).

```js
const struct = new StructureImpl(['name', 'age']);

struct.set('name', 'Max');
struct.set('age', 29);
struct.get('name');
```